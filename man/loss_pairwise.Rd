% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/loss_pairwise.R
\name{loss_pairwise}
\alias{loss_pairwise}
\title{Compute Pairwise Loss Between Two Lists of Data}
\usage{
loss_pairwise(
  datalist_A,
  datalist_B,
  loss = lossfun_hist,
  verbose = FALSE,
  write_intermediate = FALSE,
  intermediate_file = "distances_intermediate.csv",
  should_skip = function(i, j) i >= j,
  take_time = FALSE,
  return_as_matrix = TRUE,
  ...
)
}
\arguments{
\item{datalist_A}{A list of data objects (e.g., matrices, data frames, vectors).
Should be such that the loss can be computed between any two elements.
Usually I expect a list of numeric matrices.

This list corresponds to the rows of the output matrix.}

\item{datalist_B}{A list of data objects (e.g., matrices, data frames, vectors).
Should be such that the loss can be computed between any two elements.
Usually I expect a list of numeric matrices.

This list corresponds to the columns of the output matrix.}

\item{loss}{A function taking two arguments (elements from \code{datalist_A} and \code{datalist_B}) and
returning a (numeric) loss.}

\item{verbose}{Logical; if \code{TRUE}, progress messages during execution.}

\item{write_intermediate}{Logical; if \code{TRUE}, writes each computed result to a CSV file (\code{distances_intermediate.csv}).
The file looks like this:
\preformatted{
sample_A_i,sample_B_j,dist,time
1,1,0.123,0.456
1,2,0.789,0.012
...
}}

\item{should_skip}{A function with signature \verb{function(i, j)} returning \code{TRUE} if the pair (i, j)
should be skipped and its loss NOT calculated.
By default, the function skips all pairs where \code{i >= j}. This is useful for symmetric loss functions
where loss(A,A) = 0 and loss(A,B) = loss(B,A).

Useful should_skip functions are:
\itemize{
\item \code{function(i, j) i >= j} to skip the upper triangle and diagonal of all possible pairs.
\item \code{function(i, j) FALSE} to calculate all possible pairs.
\item \code{function(i, j) i == j} to skip the diagonal
\item \code{function(i, j) i == 1} to skip the first row
\item \code{function(i, j) i == 1 || j == 1} to skip the first row and column
}}

\item{take_time}{Logical; if \code{TRUE}, take timing information.}

\item{...}{Additional arguments passed to the \code{loss} function.}
}
\value{
Invisibly returns \code{NULL}. Results are written to \code{distances_intermediate.csv} if \code{write_intermediate = TRUE}.
}
\description{
Computes a pairwise loss matrix between two lists of data objects using a user-defined loss function.
Optionally supports parallelization, skipping combinations, verbose output, and intermediate result writing.
}
\details{
For each combination of \code{datalist_A[[i]]} and \code{datalist_B[[j]]}, unless skipped by \code{should_skip(i, j)},
the function calculates the loss and optionally stores the result with computation time in an intermediate CSV file.

If \code{parallel = TRUE}, the function uses nested \code{future_lapply} calls from the \code{future.apply} package.
}
\examples{
# Define dummy data and a simple loss function
A <- list(a = 1:5, b = 6:10)
B <- list(c = 1:5, d = 6:10)
loss_fn <- function(x, y) sum((x - y)^2)

# Compute pairwise loss
loss_pairwise(A, B, loss = loss_fn, verbose = FALSE, write_intermediate = FALSE)

}
